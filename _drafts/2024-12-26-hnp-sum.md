---
title: "The Hidden Number Problem with Small Unknown Multipliers: Cryptanalyzing MEGA in Six Queries and Other Applications"
description: A paper review for HNP-SUM
header: "Paper Review"
lang: ko
---

본 글에서는 MEGA의 취약점에 다룬 [해당 논문](https://eprint.iacr.org/2022/914.pdf)에 대해 소개합니다.

해당 논문은 [MEGA: Malleable Encryption Goes Awry](https://eprint.iacr.org/2022/959.pdf)에서 소개된 공격 표면에서 격자를 활용한 방법으로 실제 공격을 현실적으로 가능한 수준으로 개선합니다.

### MEGA의 구성

위의 두 논문을 소개하기에 앞서, 간편화한 MEGA의 인스턴스를 소개하겠습니다.

MEGA 인스턴스는 유저가 계정을 생성하였을 때와 유저가 로그인을 시도할 때에만 동작한다고 가정합니다.

#### 1. 유저 계정 생성 시 

클라이언트는 다음의 두 키를 생성합니다.

- master key (16byte, 이하 $k_m$으로 표기)
    - AES 암호화를 위한 키입니다.
    - 본 인스턴스에서는 ECB 모드만 이용하므로 iv는 필요하지 않습니다.
- shared key (RSA2048 비밀키, 이하 $sk_\text{shared}$로 표기)
    - RSA2048의 비밀키입니다.
    - $p,q$ : 공개키 $N$의 서로 다른 두 소인수입니다. 각각 1024비트의 소수입니다.
    - $d$ : 비밀 지수입니다. 공개 지수 $e$에 대해 $ed\equiv_{\phi(N)} 1$을 만족합니다.
    - $u$: $q^{-1}\text{ mod }p$로 정의되는 값입니다. CRT-RSA에서 연산 속도 향상을 위해 저장합니다.

> 논문 작성 시점에서 MEGA 웹 클라이언트는 공개 지수 $e$로 $257$을 사용했습니다.\
일반적으로 권장되는 $65537$과 비교하여 매우 작은 값이며, 흔히 $e=257$의 셋업을 쓰는 경우 다양한 대수적인 공격 옵션이 생깁니다.

해당 정보가 생성된 후 shared key $sk_\text{share}$은 다음과 같이 $sk_\text{shared}^\text{encoded}$으로 직렬화한 후 master key $k_m$를 이용하여 AES ECB 모드로 암호화한 값 $ct$가 서버에 저장됩니다.

$$
sk_\text{shared}^\text{encoded} = l(q)\Vert q\Vert l(p)\Vert p\Vert l(d)\Vert d\Vert l(u)\Vert u\Vert P
$$

$l(x)$는 $x$의 비트 길이를 의미하는 2바이트 값이며 $P$는 16바이트 정렬을 맞추기 위한 패딩입니다. 패딩을 제외한 값의 총 길이가 648바이트이므로 패딩 $P$는 8바이트로 구성됩니다.

![ct의 블럭 구조](/img/hnp-sum/block-alignment.jpeg)

위 이미지에서 붉게 표기된 1-8, 18, 34-40번 블럭이 두 논문에서 주요하게 이용되는 블럭입니다.

#### 2. 유저 로그인 시

유저의 로그인 시도가 발생하면 서버는 다음과 같은 challenge $C$를 생성하여 클라이언트에 전송합니다.

$$
C := (SID_\text{enc},ct)
$$

클라이언트는 challenge $C$를 수신하고 다음의 계산과정을 통해 $SID$를 얻고 이를 회신합니다.

$$
\begin{matrix}
m_p & := & c^{d\text{ mod }(p-1)}\text{ mod }p \\
m_q & := & c^{d\text{ mod }(q-1)}\text{ mod }q \\
m & := & ((m_p-m_q)u\text{ mod }p)q + m_q \\
SID & := & m[2:44]
\end{matrix}
$$

정상적인 서버는 해당 값이 $SID^e\text{ mod }N = SID_\text{enc}$를 만족하는지 확인합니다.

---

### MEGA: Malleable Encryption Goes Awry

서술의 편의를 위해 $r:=\min{p,q}$라고 정의하겠습니다. CRT-RSA 복호화의 마지막 계산 식인

$$
m := ((m_p-m_q)u\text{ mod }p)q + m_q
$$

에서 $m_p-m_q\neq 0$, 즉 $m_p \neq m_q$일 필요충분조건은 $m\ge r$입니다.

이때, 이 식을 계산할 때 사용되는 $p,q,d,u$는 **서버**가 제공한 $ct$로부터 $sk_\text{shared}$를 계산하여 도출한다는 사실에 주목해봅시다.

이는 서버가 원한다면 $sk_\text{shared}$를 원본과 다른 값으로 바꿀 수 있음을 의미합니다.

> $sk_\text{shared}$는 암호화된 상태로 서버에 존재하므로 아주 원하는 값으로 바꾸는 것은 물론 어렵습니다.\
다만 해당 값의 무결성이 보장되지 않음은 이 논문에서 중요하게 작용합니다.

그렇다면 단순하게 떠오르는 방법은, 비밀키 중 어떤 수가 변조되었을 때 변조된 방법을 몰라도 $p,q$에 관한 유의미한 정보를 얻을 수 있는지 살펴보는 것입니다.

저자가 제시한 방법은 $ct$의 40번 블럭을 임의의 값으로 변경하여 $ct^\prime$을 만듦으로써 $u$이 서버가 알 수 없게 변조된 $u^\prime$을 이용하여 어떤 응답을 하는지 확인하는 것입니다.

> 이러한 점에서 서버는 유저의 로그인 시도를 일종의 **오라클**(oracle)로써 활용하고 있다 볼 수 있습니다.

서버가 적당한 $x$를 고른 후 클라이언트에 challenge $C:=(x^e\text{ mod }N, ct^\prime)$을 전송했을 때를 자세히 살펴봅시다.

#### 1. $x<r$일 때

$x<r$ 이라면 $m_p=m_q$이므로 클라이언트가 계산한 평문 $m^\prime$은 $m_q$와 동일합니다.

이는 1024비트 이하의 값이므로 하위 128바이트 이내에 모두 포함됩니다. 즉, $SID:=m^\prime[2:44]=0$이 성립합니다.

#### 2. $x\ge r$일 때

$m_p\neq m_q$이므로 이 값에 관해서 크게 이야기할 만한 성질을 찾을 수 없습니다. 높은 확률로 $SID\neq 0$입니다.

위 결과를 종합하자면, $x,r$의 대소관계에 따라 $SID=0$일 확률이 한 케이스에서는 1, 다른 케이스에서는 0에 매우 가깝습니다. 

따라서 이러한 결과를 이용하여 $r$을 찾기 위한 이분탐색을 시행할 수 있고, $r$은 1024비트의 소수이므로 1024번의 로그인 시도를 통해 $r$의 값을 확실하게 구할 수 있습니다.

#### 로그인 횟수 줄이기

하지만 1024번의 로그인 시도는 현실적으로 불가능하며, 가능하더라도 상당히 긴 수집 기간이 필요합니다.

$n$번의 이분탐색 루프를 통해 후보군을 $2^{-n}$배로 줄일 수 있다는 사실을 이용하면 이를 조금 더 줄일 수 있습니다.

512번의 로그인 시도를 이용하여 $r$의 상위 512비트를 구하고, 나머지 하위 512비트는 Coppersmith's method를 사용해 계산하는 것입니다. 해당 내용은 논문의 3.D.1 절에 설명되어있습니다.

[저자의 실제 PoC](https://github.com/MEGA-Awry/attacks-poc/blob/main/issue_01/rsa_key_recovery_attack.py)에서는 오라클 쿼리를 통해 상위 683비트를 얻은 후 Coppersmith's method를 적용하는 것을 확인할 수 있습니다.

### HNP-SUM: Cryptanalyzing MEGA in Six Queries and Other Applications

본 논문의 저자는 원 논문의 공격에 대해 다음과 같은 점을 지적했습니다.

- Coppersmith's method의 SOTA를 고려할 때, 최소 512번의 비현실적인 수의 로그인 시도가 필요하다.
- 클라이언트는 각 challenge에 대해 344비트의 정보를 제공하나, 이를 이분탐색에서 1비트의 정보로만 소모한다.

오라클이 제공하는 정보가 기존 공격에서 활용하는 1비트보다 압도적으로 많다는 것은 오라클의 출력에서 더 많은 정보를 얻을 방법이 있을 수도 있다는 것을 의미합니다.

저자는 원 논문에서와 마찬가지로 CRT-RSA의 마지막 식에 주목했습니다.

$$
m := ((m_p-m_q)u\text{ mod }p)q + m_q
$$

위 식은 오라클의 출력이 쿼리에 따라 변하지 않는 값인 $q$에 대한 선형식으로 표현됨을 보여줍니다. 비록 긴 접미배열이 제거된 채로 출력되지만, 이러한 점은 **Hidden Number Problem**(이하 HNP)에서 잘 다뤄지는 종류의 정보 손실입니다.

저자는 이를 형식화하여 본 문제에 적합한 형태의 HNP 변형인 **HNP-SUM**을 소개합니다.

#### HNP with Small Unknown Multiplier

$N,a_i,T,E$가 주어질 때 $1\le i\le n$인 $i$에 대해

$$
\begin{matrix}
a_i \equiv _N t_i x + e_i \\
\vert t_i\vert \le T \\
\vert e_i\vert \le E \\
\end{matrix}
$$

를 만족하는 $x,t_i,e_i$가 존재한다. 모든 $t_i$를 구하여라.

위 문제가 HNP-SUM의 정의입니다만, 식의 형태 상 $t_i$의 부호, 공약수 관계까지 모두 준수하며 구하는 것은 격자로 구하기 다소 어렵습니다. 따라서 부호와 공약수 정도의 오차를 감안하고 구하는 것이 HNP-SUM을 해결하는 것의 최종적인 목표가 됩니다.

#### HNP-SUM to MEGA RSA Key Recovery

HNP-SUM을 직접 해결하기 이전에, MEGA RSA의 키 복구 공격이 HNP-SUM을 풀 수 있을 때 가능함을 먼저 짚어보겠습니다.

